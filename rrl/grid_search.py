"""
Grid search for RRL hyperparameters on Boston Housing regression task
Optimizes for R² score
"""

import os
import subprocess
import re
import pandas as pd
from itertools import product
import time
from datetime import datetime

# Base command template
BASE_CMD = [
    'python3', 'experiment.py',
    '-d', 'boston_housing',
    '--task_type', 'regression',
    '--nlaf',
    '--print_rule',
    '-ki', '0',
    '-i', '0',
    '-nr', '0',
    '-ma', '127.0.0.1',
    '-mp', '0',
    '-li', '500',
]

# Hyperparameter grid to search
# You can modify this to focus on specific parameters
PARAM_GRID = {
    'batch_size': [32],
    'structure': ['10@64', '10@96', '12@64'],
    'epoch': [1000],
    'learning_rate': [0.001, 0.002, 0.005],
    'lr_decay_rate': [0.75],
    'lr_decay_epoch': [100, 200],
    'weight_decay': [0.0001, ],
    'alpha': [0.999],
    'beta': [3, 8],
    'gamma': [1, 3],
}

# Smaller grid for quick testing (uncomment to use)
# PARAM_GRID = {
#     'batch_size': [32],
#     'structure': ['10@64'],
#     'epoch': [800],
#     'learning_rate': [0.001, 0.002],
#     'lr_decay_rate': [0.75],
#     'lr_decay_epoch': [200],
#     'weight_decay': [0.0, 0.0001],
#     'alpha': [0.9, 0.999],
#     'beta': [3, 8],
#     'gamma': [1, 3],
# }

# Fixed parameters (from base command)
FIXED_PARAMS = {
    'data_set': 'boston_housing',
    'task_type': 'regression',
    'nlaf': True,
    'print_rule': True,
    'ith_kfold': 0,
    'device_ids': '0',
    'round_count': 0,
}


def parse_test_result(test_res_file):
    """Parse R² score from test_res.txt file"""
    if not os.path.exists(test_res_file):
        return None
    
    try:
        with open(test_res_file, 'r') as f:
            content = f.read()
        
        # Look for R2 Score line
        r2_match = re.search(r'R2 Score.*?:\s*([\d.]+)', content)
        if r2_match:
            r2_score = float(r2_match.group(1))
            return r2_score
        
        # Alternative pattern
        r2_match = re.search(r'R² Score.*?:\s*([\d.]+)', content)
        if r2_match:
            r2_score = float(r2_match.group(1))
            return r2_score
        
        return None
    except Exception as e:
        print(f"Error parsing {test_res_file}: {e}")
        return None


def run_experiment(params):
    """Run a single experiment with given parameters"""
    cmd = BASE_CMD.copy()
    
    # Add hyperparameters
    cmd.extend(['-bs', str(params['batch_size'])])
    cmd.extend(['-s', params['structure']])
    cmd.extend(['-e', str(params['epoch'])])
    cmd.extend(['-lr', str(params['learning_rate'])])
    cmd.extend(['-lrdr', str(params['lr_decay_rate'])])
    cmd.extend(['-lrde', str(params['lr_decay_epoch'])])
    cmd.extend(['-wd', str(params['weight_decay'])])
    cmd.extend(['--alpha', str(params['alpha'])])
    cmd.extend(['--beta', str(params['beta'])])
    cmd.extend(['--gamma', str(params['gamma'])])
    cmd.extend(['-i', params['device_ids']])
    
    print(f"\n{'='*80}")
    print(f"Running experiment with parameters:")
    for key, value in params.items():
        print(f"  {key}: {value}")
    print(f"{'='*80}\n")
    
    try:
        # Run the experiment
        result = subprocess.run(cmd, capture_output=True, text=True, timeout=7200)  # 2 hour timeout
        
        if result.returncode != 0:
            print(f"Experiment failed with return code {result.returncode}")
            print(f"Error output: {result.stderr}")
            return None
        
        # Find the result file by searching for the most recently created folder matching our parameters
        # The folder name is generated by args.py with specific format
        log_dir = os.path.join('log_folder', 'boston_housing')
        if not os.path.exists(log_dir):
            return None
        
        # Find the result file by searching for the most recently created folder matching our parameters
        # Wait a bit for the folder to be created
        time.sleep(2)
        
        matching_folders = []
        if os.path.exists(log_dir):
            for folder in os.listdir(log_dir):
                folder_path = os.path.join(log_dir, folder)
                if os.path.isdir(folder_path):
                    # Check if folder matches key parameters (use flexible matching)
                    matches = True
                    # Check epoch
                    if f"_e{params['epoch']}_" not in folder:
                        matches = False
                    # Check batch size
                    if f"_bs{params['batch_size']}_" not in folder:
                        matches = False
                    # Check learning rate (handle float formatting)
                    lr_str = str(params['learning_rate'])
                    if f"_lr{lr_str}_" not in folder and f"_lr{lr_str}0_" not in folder:
                        matches = False
                    # Check structure
                    if f"_L{params['structure']}" not in folder:
                        matches = False
                    # Check alpha, beta, gamma
                    if f"_alpha{params['alpha']}_" not in folder:
                        matches = False
                    if f"_beta{params['beta']}_" not in folder:
                        matches = False
                    if f"_gamma{params['gamma']}_" not in folder:
                        matches = False
                    # Check for NLAF
                    if "_useNLAFTrue_" not in folder:
                        matches = False
                    
                    if matches:
                        matching_folders.append(folder_path)
        
        if matching_folders:
            # Use the most recently modified folder
            matching_folders.sort(key=lambda x: os.path.getmtime(x), reverse=True)
            test_res_file = os.path.join(matching_folders[0], 'test_res.txt')
        else:
            test_res_file = None
        
        # Parse R² score
        r2_score = parse_test_result(test_res_file)
        
        if r2_score is not None:
            print(f"✓ R² Score: {r2_score:.4f}")
        else:
            print(f"✗ Failed to parse R² score from {test_res_file}")
        
        return {
            'r2_score': r2_score,
            'test_res_file': test_res_file,
            'success': r2_score is not None
        }
    except subprocess.TimeoutExpired:
        print(f"✗ Experiment timed out after 2 hours")
        return None
    except Exception as e:
        print(f"✗ Experiment failed with error: {e}")
        return None


def main():
    print("="*80)
    print("RRL Hyperparameter Grid Search for Boston Housing Regression")
    print("Optimizing for R² Score")
    print("="*80)
    
    # Generate all parameter combinations
    param_names = list(PARAM_GRID.keys())
    param_values = list(PARAM_GRID.values())
    total_combinations = 1
    for values in param_values:
        total_combinations *= len(values)
    
    print(f"\nTotal parameter combinations: {total_combinations}")
    print(f"Estimated time: ~{total_combinations * 1 / 60:.1f} hours (assuming 1 min per experiment)")
    
    # Ask for confirmation
    response = input("\nProceed with grid search? (yes/no): ")
    if response.lower() not in ['yes', 'y']:
        print("Grid search cancelled.")
        return
    
    results = []
    start_time = time.time()
    
    # Iterate through all combinations
    for idx, param_combo in enumerate(product(*param_values), 1):
        params = dict(zip(param_names, param_combo))
        params.update(FIXED_PARAMS)
        
        print(f"\n[{idx}/{total_combinations}] Experiment {idx}")
        print(f"Progress: {idx/total_combinations*100:.1f}%")
        
        result = run_experiment(params)
        
        if result:
            result.update(params)
            results.append(result)
        else:
            # Still record the attempt
            failed_result = params.copy()
            failed_result.update({
                'r2_score': None,
                'test_res_file': None,
                'success': False
            })
            results.append(failed_result)
        
        # Save intermediate results
        if idx % 5 == 0 or idx == total_combinations:
            results_df = pd.DataFrame(results)
            results_df = results_df.sort_values('r2_score', ascending=False, na_position='last')
            output_file = 'grid_search_results.csv'
            results_df.to_csv(output_file, index=False)
            print(f"\nIntermediate results saved to {output_file}")
            
            if len(results_df[results_df['r2_score'].notna()]) > 0:
                best = results_df[results_df['r2_score'].notna()].iloc[0]
                print(f"Current best R²: {best['r2_score']:.4f}")
                print(f"Best params: lr={best['learning_rate']}, wd={best['weight_decay']}, "
                      f"structure={best['structure']}, alpha={best['alpha']}, beta={best['beta']}, gamma={best['gamma']}")
    
    # Final summary
    elapsed_time = time.time() - start_time
    print("\n" + "="*80)
    print("Grid Search Complete!")
    print("="*80)
    print(f"Total time: {elapsed_time/3600:.2f} hours")
    print(f"Total experiments: {len(results)}")
    print(f"Successful experiments: {sum(1 for r in results if r.get('success', False))}")
    
    # Save final results
    results_df = pd.DataFrame(results)
    results_df = results_df.sort_values('r2_score', ascending=False, na_position='last')
    output_file = 'grid_search_results.csv'
    results_df.to_csv(output_file, index=False)
    print(f"\nResults saved to {output_file}")
    
    # Print top 10 results
    print("\n" + "="*80)
    print("Top 10 Results (by R² Score):")
    print("="*80)
    top_results = results_df[results_df['r2_score'].notna()].head(10)
    if len(top_results) > 0:
        for idx, row in top_results.iterrows():
            print(f"\nRank {len(top_results) - list(top_results.index).index(idx)}:")
            print(f"  R² Score: {row['r2_score']:.4f}")
            print(f"  Parameters:")
            print(f"    batch_size: {row['batch_size']}")
            print(f"    structure: {row['structure']}")
            print(f"    epoch: {row['epoch']}")
            print(f"    learning_rate: {row['learning_rate']}")
            print(f"    lr_decay_rate: {row['lr_decay_rate']}")
            print(f"    lr_decay_epoch: {row['lr_decay_epoch']}")
            print(f"    weight_decay: {row['weight_decay']}")
            print(f"    alpha: {row['alpha']}")
            print(f"    beta: {row['beta']}")
            print(f"    gamma: {row['gamma']}")
    else:
        print("No successful experiments found.")
    
    # Print best configuration
    if len(results_df[results_df['r2_score'].notna()]) > 0:
        best = results_df[results_df['r2_score'].notna()].iloc[0]
        print("\n" + "="*80)
        print("Best Configuration:")
        print("="*80)
        print(f"R² Score: {best['r2_score']:.4f}")
        print(f"\nCommand to reproduce:")
        cmd_parts = [
            'python3', 'experiment.py',
            '-d', 'boston_housing',
            '-bs', str(int(best['batch_size'])),
            '-s', best['structure'],
            '-e', str(int(best['epoch'])),
            '-lr', str(best['learning_rate']),
            '-lrdr', str(best['lr_decay_rate']),
            '-lrde', str(int(best['lr_decay_epoch'])),
            '-wd', str(best['weight_decay']),
            '-ki', '0',
            '-i', '0',
            '--print_rule',
            '--task_type', 'regression',
            '--nlaf',
            '--alpha', str(best['alpha']),
            '--beta', str(int(best['beta'])),
            '--gamma', str(int(best['gamma'])),
        ]
        print(' '.join(cmd_parts))


if __name__ == '__main__':
    main()

